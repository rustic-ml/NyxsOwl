//! Implementation of a trading strategy that uses forecasting methods
//! to predict price movements and generate trading signals.

use crate::RealtimeTradingStrategy;
use chrono::{DateTime, Utc};
use std::collections::VecDeque;
use trade_math::forecasting::{DoubleExponentialSmoothing, LinearRegression};
use trade_math::MathError;

/// Trading signal types that can be generated by the strategy
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ForecastSignal {
    /// Strong buy signal based on forecasted uptrend
    StrongBuy,
    /// Moderate buy signal
    Buy,
    /// Hold current position
    Hold,
    /// Moderate sell signal
    Sell,
    /// Strong sell signal based on forecasted downtrend
    StrongSell,
}

/// A trading strategy that uses forecasting methods to predict price movements
/// and generate trading signals based on those predictions.
#[derive(Debug)]
pub struct ForecastingStrategy {
    // Configuration
    price_window: usize,
    regression_period: usize,
    exp_smoothing_alpha: f64,
    exp_smoothing_beta: f64,
    buy_threshold: f64,
    strong_buy_threshold: f64,
    sell_threshold: f64,
    strong_sell_threshold: f64,

    // State
    prices: VecDeque<f64>,
    timestamps: VecDeque<DateTime<Utc>>,
    linear_regression: LinearRegression,
    exp_smoothing: DoubleExponentialSmoothing,
    last_signal: Option<ForecastSignal>,
}

impl ForecastingStrategy {
    /// Create a new ForecastingStrategy with default parameters
    pub fn new() -> Result<Self, MathError> {
        Self::with_params(
            20,   // price_window
            15,   // regression_period
            0.3,  // exp_smoothing_alpha
            0.2,  // exp_smoothing_beta
            0.5,  // buy_threshold (% expected increase)
            1.0,  // strong_buy_threshold
            -0.5, // sell_threshold (% expected decrease)
            -1.0, // strong_sell_threshold
        )
    }

    /// Create a new ForecastingStrategy with custom parameters
    pub fn with_params(
        price_window: usize,
        regression_period: usize,
        exp_smoothing_alpha: f64,
        exp_smoothing_beta: f64,
        buy_threshold: f64,
        strong_buy_threshold: f64,
        sell_threshold: f64,
        strong_sell_threshold: f64,
    ) -> Result<Self, MathError> {
        Ok(Self {
            price_window,
            regression_period,
            exp_smoothing_alpha,
            exp_smoothing_beta,
            buy_threshold,
            strong_buy_threshold,
            sell_threshold,
            strong_sell_threshold,
            prices: VecDeque::with_capacity(price_window),
            timestamps: VecDeque::with_capacity(price_window),
            linear_regression: LinearRegression::new(regression_period)?,
            exp_smoothing: DoubleExponentialSmoothing::new(
                exp_smoothing_alpha,
                exp_smoothing_beta,
            )?,
            last_signal: None,
        })
    }

    /// Add a new price data point to the strategy
    pub fn add_price(&mut self, timestamp: DateTime<Utc>, price: f64) -> Result<(), MathError> {
        // Add to price history
        self.prices.push_back(price);
        self.timestamps.push_back(timestamp);

        // Keep only the required window of prices
        if self.prices.len() > self.price_window {
            self.prices.pop_front();
            self.timestamps.pop_front();
        }

        // Update forecasting models
        self.linear_regression.update(price)?;
        self.exp_smoothing.update(price)?;

        Ok(())
    }

    /// Get the current forecast signal based on the prediction models
    pub fn get_forecast_signal(&self) -> Result<ForecastSignal, MathError> {
        // Only generate signals when we have enough data
        if self.prices.len() < self.regression_period {
            return Ok(ForecastSignal::Hold);
        }

        // Get current price
        let current_price = *self.prices.back().unwrap();

        // Calculate expected price change percentage over the next 5 periods
        let lr_forecast = self.linear_regression.forecast(5)?;
        let exp_forecast = self.exp_smoothing.forecast(5)?;

        // Combine forecasts (simple average)
        let combined_forecast = (lr_forecast + exp_forecast) / 2.0;

        // Calculate the percentage change from current price
        let percent_change = (combined_forecast - current_price) / current_price * 100.0;

        // Generate signal based on forecasted change
        let signal = if percent_change >= self.strong_buy_threshold {
            ForecastSignal::StrongBuy
        } else if percent_change >= self.buy_threshold {
            ForecastSignal::Buy
        } else if percent_change <= self.strong_sell_threshold {
            ForecastSignal::StrongSell
        } else if percent_change <= self.sell_threshold {
            ForecastSignal::Sell
        } else {
            ForecastSignal::Hold
        };

        Ok(signal)
    }

    /// Get regression parameters for analysis
    pub fn get_regression_info(&self) -> Result<(f64, f64), MathError> {
        let slope = self.linear_regression.slope()?;
        let r_squared = self.linear_regression.r_squared()?;

        Ok((slope, r_squared))
    }

    /// Get exponential smoothing parameters for analysis
    pub fn get_exp_smoothing_info(&self) -> Result<(f64, f64), MathError> {
        let level = self.exp_smoothing.level()?;
        let trend = self.exp_smoothing.trend()?;

        Ok((level, trend))
    }
}

impl RealtimeTradingStrategy for ForecastingStrategy {
    fn update(
        &mut self,
        timestamp: DateTime<Utc>,
        open: f64,
        high: f64,
        low: f64,
        close: f64,
        volume: f64,
    ) -> Result<(), String> {
        // Use the closing price for our forecasting
        self.add_price(timestamp, close)
            .map_err(|e| format!("Error updating forecasting models: {}", e))
    }

    fn generate_signal(&self) -> Result<i8, String> {
        let forecast_signal = self
            .get_forecast_signal()
            .map_err(|e| format!("Error generating forecast signal: {}", e))?;

        // Convert ForecastSignal to the TradingStrategy i8 signal convention
        let signal = match forecast_signal {
            ForecastSignal::StrongBuy => 2,
            ForecastSignal::Buy => 1,
            ForecastSignal::Hold => 0,
            ForecastSignal::Sell => -1,
            ForecastSignal::StrongSell => -2,
        };

        Ok(signal)
    }

    fn name(&self) -> &str {
        "Forecasting Strategy"
    }

    fn reset(&mut self) {
        self.prices.clear();
        self.timestamps.clear();
        self.linear_regression.reset();
        self.exp_smoothing.reset();
        self.last_signal = None;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::TimeZone;

    #[test]
    fn test_forecasting_strategy() {
        let mut strategy = ForecastingStrategy::new().unwrap();

        // Add a series of prices with an uptrend
        let base_time = Utc.timestamp_opt(1609459200, 0).unwrap(); // 2021-01-01

        // Generate some test data with an uptrend
        for i in 0..25 {
            let timestamp = base_time + chrono::Duration::days(i);
            let price = 100.0 + (i as f64 * 2.0) + (rand::random::<f64>() * 5.0 - 2.5);

            strategy
                .update(timestamp, price, price + 1.0, price - 1.0, price, 1000.0)
                .unwrap();

            if i >= 15 {
                // After enough data points, check that we get a buy signal on an uptrend
                let signal = strategy.generate_signal().unwrap();
                assert!(
                    signal >= 0,
                    "Expected non-negative signal for uptrend, got {}",
                    signal
                );

                if i >= 20 {
                    // With a strong uptrend, we should get a strong buy
                    assert!(
                        signal > 0,
                        "Expected positive signal for strong uptrend, got {}",
                        signal
                    );
                }
            }
        }

        // Reset and test with a downtrend
        strategy.reset();

        for i in 0..25 {
            let timestamp = base_time + chrono::Duration::days(i);
            let price = 150.0 - (i as f64 * 2.0) + (rand::random::<f64>() * 5.0 - 2.5);

            strategy
                .update(timestamp, price, price + 1.0, price - 1.0, price, 1000.0)
                .unwrap();

            if i >= 15 {
                // After enough data points, check that we get a sell signal on a downtrend
                let signal = strategy.generate_signal().unwrap();
                assert!(
                    signal <= 0,
                    "Expected non-positive signal for downtrend, got {}",
                    signal
                );

                if i >= 20 {
                    // With a strong downtrend, we should get a strong sell
                    assert!(
                        signal < 0,
                        "Expected negative signal for strong downtrend, got {}",
                        signal
                    );
                }
            }
        }
    }
}
